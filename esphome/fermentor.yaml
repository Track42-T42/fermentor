substitutions:
  dev_name: fermenter
  friendly_name: Fermenter

  # Safety thresholds (in °C)
  safety_max_c_normal: "57"   # soft limit in Normal mode
  safety_clear_c_normal: "47"
  safety_max_c_high: "78"     # soft limit in High-Temp mode (black garlic, miso...)
  safety_clear_c_high: "68"
  safety_hard_c: "85"         # absolute hard limit, all modes

  # Compressor timing (kept for future use / info)
  compressor_min_off_min: "5"
  compressor_min_on_min: "2"

esphome:
  name: ${dev_name}
  comment: Fermentation chamber controller (ESP32 + 6-relay + AHT20 + dual DS18B20 + selector + mist post-run + door light hold + humidifier dry detect + turbo heater)
  on_boot:
    priority: -100
    then:
      - delay: 2s
      - climate.control:
          id: temp_ctrl
          mode: HEAT
      - switch.turn_on: dry_alerts_enabled

esp32:
  board: esp32dev

wifi:
  ssid: !secret wifi_ssid
  password: !secret wifi_password
  fast_connect: true
  reboot_timeout: 5min
  power_save_mode: none
  ap:
    ssid: "${friendly_name} Fallback AP"
    password: "fermenter123"

api:
  encryption:
    key: "CXcjj0aUsTEuJP/ny2nrsnuNVOfvukaE0b4ArdgeBlg="
  reboot_timeout: 0s
  port: 6053

ota:
  - platform: esphome

logger:

web_server:
  port: 80

i2c:
  id: bus0
  sda: GPIO21
  scl: GPIO22
  scan: true
  frequency: 100kHz

one_wire:
  - platform: gpio
    pin: GPIO4
    id: onewire_ext1
  - platform: gpio
    pin: GPIO33
    id: onewire_ext2

switch:
  # Relay 1 — Light
  - platform: gpio
    id: relay_light
    name: "${friendly_name} Light"
    pin: { number: GPIO25, inverted: false }
    restore_mode: RESTORE_DEFAULT_OFF

  # Relay 2 — Heating mat
  - platform: gpio
    id: relay_heat
    name: "${friendly_name} Heating Mat"
    pin: { number: GPIO26, inverted: false }
    restore_mode: RESTORE_DEFAULT_OFF
    on_turn_on:
      then:
        # hard interlock: heat on => cool off
        - if:
            condition: { switch.is_on: relay_cool }
            then:
              - logger.log: "INTERLOCK: Heat ON -> forcing COOL OFF"
              - switch.turn_off: relay_cool
        - if:
            condition: { switch.is_on: fan_auto }
            then:
              - logger.log: "FAN: heat ON -> fan ON"
              - switch.turn_on: relay_fan
              - lambda: 'id(fan_post_left_secs) = 0;'
    on_turn_off:
      then:
        - if:
            condition: { switch.is_on: fan_auto }
            then:
              - logger.log: "FAN: heat OFF -> start post-run"
              - lambda: 'id(fan_post_left_secs) = (uint32_t)(id(fan_postrun_minutes).state * 60.0f);'

  # Relay 3 — Mist maker
  - platform: gpio
    id: relay_mist
    name: "${friendly_name} Mist Maker"
    pin: { number: GPIO27, inverted: false }
    restore_mode: RESTORE_DEFAULT_OFF
    on_turn_on:
      then:
        - if:
            condition: { switch.is_on: fan_auto }
            then:
              - logger.log: "FAN: mister ON -> fan ON immediately"
              - switch.turn_on: relay_fan
              - lambda: 'id(fan_post_left_secs) = 0;'
    on_turn_off:
      then:
        - if:
            condition: { switch.is_on: fan_auto }
            then:
              - logger.log: "FAN: mister OFF -> start post-run"
              - lambda: 'id(fan_post_left_secs) = (uint32_t)(id(fan_postrun_minutes).state * 60.0f);'

  # Relay 4 — Fan
  - platform: gpio
    id: relay_fan
    name: "${friendly_name} Fan"
    pin: { number: GPIO14, inverted: false }
    restore_mode: RESTORE_DEFAULT_OFF

  # Relay 5 — Compressor / Cooling
  - platform: gpio
    id: relay_cool
    name: "${friendly_name} Compressor (Cool)"
    pin: { number: GPIO23, inverted: false }
    restore_mode: RESTORE_DEFAULT_OFF
    on_turn_on:
      then:
        # hard interlock: cool on => heaters off
        - if:
            condition: { switch.is_on: relay_heat }
            then:
              - logger.log: "INTERLOCK: Cool ON -> forcing HEAT OFF"
              - switch.turn_off: relay_heat
        - if:
            condition: { switch.is_on: relay_turbo }
            then:
              - logger.log: "INTERLOCK: Cool ON -> forcing TURBO OFF"
              - switch.turn_off: relay_turbo
        - if:
            condition: { switch.is_on: fan_auto }
            then:
              - logger.log: "FAN: cool ON -> fan ON"
              - switch.turn_on: relay_fan
              - lambda: 'id(fan_post_left_secs) = 0;'
    on_turn_off:
      then:
        - if:
            condition: { switch.is_on: fan_auto }
            then:
              - logger.log: "FAN: cool OFF -> start post-run"
              - lambda: 'id(fan_post_left_secs) = (uint32_t)(id(fan_postrun_minutes).state * 60.0f);'

  # Relay 6 — Turbo heater
  # ⚠ If possible, move off GPIO5 to a non-strapping pin (e.g. 16/17/18/19/13)
  - platform: gpio
    id: relay_turbo
    name: "${friendly_name} Turbo Heater"
    pin: { number: GPIO5, inverted: false }
    restore_mode: RESTORE_DEFAULT_OFF
    on_turn_on:
      then:
        - if:
            condition: { switch.is_on: relay_cool }
            then:
              - logger.log: "INTERLOCK: Turbo ON -> forcing COOL OFF"
              - switch.turn_off: relay_cool
        - if:
            condition: { switch.is_on: fan_auto }
            then:
              - logger.log: "FAN: turbo ON -> fan ON"
              - switch.turn_on: relay_fan
              - lambda: 'id(fan_post_left_secs) = 0;'
    on_turn_off:
      then:
        - if:
            condition: { switch.is_on: fan_auto }
            then:
              - logger.log: "FAN: turbo OFF -> long post-run"
              - lambda: |-
                  uint32_t base = (uint32_t)(id(fan_postrun_minutes).state * 60.0f);
                  uint32_t turbo_min = 600;  // at least 10 min after turbo
                  id(fan_post_left_secs) = (base > turbo_min) ? base : turbo_min;

  # Automation toggles
  - platform: template
    id: humidify_auto
    name: "${friendly_name} Humidity Auto"
    icon: mdi:autorenew
    restore_mode: RESTORE_DEFAULT_OFF
    optimistic: true

  - platform: template
    id: fan_auto
    name: "${friendly_name} Fan Auto"
    icon: mdi:fan-auto
    restore_mode: RESTORE_DEFAULT_OFF
    optimistic: true

  - platform: template
    id: dry_alerts_enabled
    name: "${friendly_name} Humidifier Dry Alerts"
    icon: mdi:bell-alert
    restore_mode: RESTORE_DEFAULT_OFF
    optimistic: true

select:
  - platform: template
    id: temp_source_select
    name: "${friendly_name} Temperature Source"
    optimistic: true
    restore_value: true
    options: [ "AHT20", "External 1", "External 2" ]
    initial_option: "AHT20"

  # Mode selector: Normal vs High-Temp
  - platform: template
    id: mode_select
    name: "${friendly_name} Mode"
    optimistic: true
    restore_value: true
    options: [ "Normal", "High-Temp" ]
    initial_option: "Normal"

number:
  - platform: template
    id: rh_target
    name: "${friendly_name} Target Humidity"
    unit_of_measurement: "%"
    icon: mdi:water-percent
    restore_value: true
    optimistic: true
    min_value: 30
    max_value: 95
    step: 1
    initial_value: 70

  - platform: template
    id: rh_hyst
    name: "${friendly_name} RH Hysteresis"
    unit_of_measurement: "%"
    icon: mdi:delta
    restore_value: true
    optimistic: true
    min_value: 1
    max_value: 10
    step: 0.5
    initial_value: 2

  - platform: template
    id: rh_max_on_minutes
    name: "${friendly_name} Mist Max On (min)"
    icon: mdi:timer-outline
    restore_value: true
    optimistic: true
    min_value: 1
    max_value: 120
    step: 1
    initial_value: 45

  - platform: template
    id: fan_postrun_minutes
    name: "${friendly_name} Fan Post-Run (min)"
    icon: mdi:timer-outline
    restore_value: true
    optimistic: true
    min_value: 0
    max_value: 30
    step: 1
    initial_value: 3

  - platform: template
    id: dry_check_minutes
    name: "${friendly_name} Dry Check (min)"
    icon: mdi:timer-sand
    restore_value: true
    optimistic: true
    min_value: 1
    max_value: 30
    step: 1
    initial_value: 5

  - platform: template
    id: dry_expected_rise
    name: "${friendly_name} Dry Expected Rise (%)"
    unit_of_measurement: "%"
    icon: mdi:water-percent
    restore_value: true
    optimistic: true
    min_value: 0.5
    max_value: 10
    step: 0.1
    initial_value: 2

  - platform: template
    id: dry_failures_needed
    name: "${friendly_name} Dry Failures Needed"
    icon: mdi:counter
    restore_value: true
    optimistic: true
    min_value: 1
    max_value: 5
    step: 1
    initial_value: 2

button:
  - platform: restart
    name: "${friendly_name} Restart"

text_sensor:
  - platform: version
    name: "${friendly_name} ESPHome Version"

script:
  - id: door_light_timeout
    mode: restart
    then:
      - delay: 10min
      - if:
          condition:
            binary_sensor.is_off: door_sensor
          then:
            - switch.turn_off: relay_light

binary_sensor:
  # Mode-aware overtemp trip
  - platform: template
    id: overtemp_trip
    name: "${friendly_name} Overtemp Trip"
    device_class: safety
    lambda: |-
      const float t = id(t_ctrl).state;
      if (!isfinite(t)) return false;
      const bool high_mode = (id(mode_select).state == "High-Temp");
      const float soft_normal = ${safety_max_c_normal};
      const float soft_high   = ${safety_max_c_high};
      const float hard_limit  = ${safety_hard_c};
      if (t > hard_limit) return true;
      if (high_mode) return (t > soft_high);
      else return (t > soft_normal);
    filters:
      - delayed_on: 5s

  - platform: gpio
    id: door_sensor
    name: "${friendly_name} Door"
    device_class: door
    pin:
      number: GPIO32
      mode: INPUT_PULLUP
    filters:
      - delayed_on: 50ms
      - delayed_off: 50ms
    on_press:
      then:
        - if:
            condition:
              not:
                switch.is_on: relay_light
            then:
              - switch.turn_on: relay_light
              - lambda: 'id(door_forced_light) = true;'
            else:
              - lambda: 'id(door_forced_light) = false;'
        - script.execute: door_light_timeout
        # High-temp door safety: kill turbo if door opens hot
        - lambda: |-
            const float t = id(t_ctrl).state;
            if ((id(mode_select).state == "High-Temp") && isfinite(t) && t > 40.0f) {
              ESP_LOGW("safety", "Door opened in High-Temp at %.1f°C -> TURBO OFF", t);
              id(relay_turbo).turn_off();
            }
    on_release:
      then:
        - if:
            condition:
              lambda: 'return id(door_forced_light);'
            then:
              - switch.turn_off: relay_light
              - lambda: 'id(door_forced_light) = false;'
        - script.stop: door_light_timeout

  - platform: template
    id: humidifier_dry_bs
    name: "${friendly_name} Humidifier Dry"
    device_class: problem
    lambda: 'return id(humidifier_dry_flag);'

sensor:
  - platform: wifi_signal
    name: "${friendly_name} WiFi RSSI"
    update_interval: 30s

  - platform: uptime
    name: "${friendly_name} Uptime"

  - platform: aht10
    i2c_id: bus0
    address: 0x38
    variant: AHT20
    temperature:
      id: t_air
      name: "${friendly_name} Air Temp"
      accuracy_decimals: 1
      filters:
        - median: { window_size: 5, send_every: 2, send_first_at: 1 }
    humidity:
      id: rh_air
      name: "${friendly_name} Humidity (AHT20)"
      accuracy_decimals: 1
      filters:
        - median: { window_size: 5, send_every: 2, send_first_at: 1 }
    update_interval: 5s

  - platform: dallas_temp
    one_wire_id: onewire_ext1
    name: "${friendly_name} External 1"
    id: t_ext1
    update_interval: 10s
    accuracy_decimals: 1
    filters:
      - median: { window_size: 5, send_every: 2, send_first_at: 1 }

  - platform: dallas_temp
    one_wire_id: onewire_ext2
    name: "${friendly_name} External 2"
    id: t_ext2
    update_interval: 10s
    accuracy_decimals: 1
    filters:
      - median: { window_size: 5, send_every: 2, send_first_at: 1 }

  - platform: template
    id: t_ctrl
    name: "${friendly_name} Control Temp"
    unit_of_measurement: "°C"
    device_class: temperature
    state_class: measurement
    accuracy_decimals: 1
    update_interval: 5s
    lambda: |-
      auto src = id(temp_source_select).state;
      float v = NAN;
      if (src == "AHT20")           v = id(t_air).state;
      else if (src == "External 1") v = id(t_ext1).state;
      else if (src == "External 2") v = id(t_ext2).state;
      if (isnan(v)) v = id(t_air).state;
      return v;

time:
  - platform: sntp
    id: sntp_time

# CLIMATE (original thermostat with mat + compressor)
climate:
  - platform: thermostat
    id: temp_ctrl
    name: "${friendly_name} Temperature"
    sensor: t_ctrl

    on_boot_restore_from: default_preset
    default_preset: Ferment
    
    on_state:
      then:
        - lambda: |-
            // 1. HVAC OFF => force outputs off
            if (id(temp_ctrl).mode == climate::CLIMATE_MODE_OFF) {
              ESP_LOGD("thermo", "HVAC OFF -> cut HEAT & COOL, start fan post-run");
              id(relay_heat).turn_off();
              id(relay_cool).turn_off();
              id(fan_post_left_secs) = (uint32_t)(id(fan_postrun_minutes).state * 60.0f);
              return;
            }

    # HEAT
    heat_action:
      - logger.log: "THERMO: heat_action => relay_heat ON"
      - switch.turn_on: relay_heat
      - if:
          condition: { switch.is_on: fan_auto }
          then:
            - logger.log: "FAN: thermostat heat_action -> fan ON"
            - switch.turn_on: relay_fan

    # COOL
    cool_action:
      - logger.log: "THERMO: cool_action => relay_cool ON"
      - switch.turn_on: relay_cool
      - if:
          condition: { switch.is_on: fan_auto }
          then:
            - logger.log: "FAN: thermostat cool_action -> fan ON"
            - switch.turn_on: relay_fan

    idle_action:
      - logger.log: "THERMO: idle_action => heat & cool OFF"
      - switch.turn_off: relay_heat
      - switch.turn_off: relay_cool
      - if:
          condition: { switch.is_on: fan_auto }
          then:
            - logger.log: "FAN: thermostat idle_action -> start post-run"
            - lambda: 'id(fan_post_left_secs) = (uint32_t)(id(fan_postrun_minutes).state * 60.0f);'

    min_heating_run_time: 60s
    min_heating_off_time: 60s
    min_cooling_run_time: 120s
    min_cooling_off_time: 300s
    min_idle_time: 10s

    heat_deadband: 0.3 °C
    heat_overrun: 0.4 °C
    cool_deadband: 0.3 °C
    cool_overrun: 0.4 °C

    preset:
      - name: Ferment
        default_target_temperature_low: 22 °C
        default_target_temperature_high: 22 °C
      - name: Sourdough
        default_target_temperature_low: 26 °C
        default_target_temperature_high: 26 °C
      - name: ColdCrash
        default_target_temperature_low: 4 °C
        default_target_temperature_high: 4 °C
      - name: BlackGarlic
        default_target_temperature_low: 70 °C
        default_target_temperature_high: 70 °C

    visual:
      min_temperature: 0 °C
      max_temperature: 80 °C
      temperature_step: 0.5 °C

globals:
  - id: fan_post_left_secs
    type: uint32_t
    restore_value: no
    initial_value: '0'
  - id: mist_on_secs
    type: uint32_t
    restore_value: no
    initial_value: '0'
  - id: mist_lockout_secs
    type: uint32_t
    restore_value: no
    initial_value: '0'
  - id: last_mist_on
    type: bool
    restore_value: no
    initial_value: 'false'
  - id: door_forced_light
    type: bool
    restore_value: no
    initial_value: 'false'
  - id: humidifier_dry_flag
    type: bool
    restore_value: no
    initial_value: 'false'
  - id: dry_rh_baseline
    type: float
    restore_value: no
    initial_value: '0'
  - id: dry_check_elapsed
    type: uint32_t
    restore_value: no
    initial_value: '0'
  - id: dry_fail_count
    type: uint8_t
    restore_value: no
    initial_value: '0'
  - id: cool_lockout_secs
    type: uint32_t
    restore_value: no
    initial_value: '0'

interval:
  # Sensor-failure guard (kills heat, turbo & cool)
  - interval: 2s
    then:
      - lambda: |-
          float t = id(t_ctrl).state;
          if (!isfinite(t)) {
            ESP_LOGW("safety", "t_ctrl invalid -> forcing HEAT OFF, TURBO OFF, COOL OFF");
            id(relay_heat).turn_off();
            id(relay_turbo).turn_off();
            id(relay_cool).turn_off();
            id(fan_post_left_secs) = 0;
          }
      - if:
          condition:
            lambda: 'return !isfinite(id(t_ctrl).state);'
          then:
            - climate.control:
                id: temp_ctrl
                mode: HEAT
                target_temperature_low: 0 °C
                target_temperature_high: 0 °C

  # Overtemperature cutoff (kills all heaters + cooler)
  - interval: 1s
    then:
      - if:
          condition:
            or:
              - binary_sensor.is_on: overtemp_trip
              - lambda: 'return isnan(id(t_ctrl).state);'
          then:
            - switch.turn_off: relay_heat
            - switch.turn_off: relay_turbo
            - switch.turn_off: relay_cool
      - if:
          condition:
            and:
              - binary_sensor.is_off: overtemp_trip
              - lambda: |-
                  const bool high_mode = (id(mode_select).state == "High-Temp");
                  const float clear_normal = ${safety_clear_c_normal};
                  const float clear_high   = ${safety_clear_c_high};
                  const float t = id(t_ctrl).state;
                  if (!isfinite(t)) return false;
                  const float th = high_mode ? clear_high : clear_normal;
                  return (t < th);
          then:
            - logger.log: "Safety: Overtemp cleared"

  # Humidity loop (disabled in High-Temp mode)
  - interval: 5s
    then:
      - lambda: |-
          if (!id(humidify_auto).state) return;
          if (id(mist_lockout_secs) > 0) return;
          const bool high_mode = (id(mode_select).state == "High-Temp");
          if (high_mode) {
            // No ultrasonic humidifier in High-Temp mode
            return;
          }

          const float rh = id(rh_air).state;
          const float target = id(rh_target).state;
          const float h = id(rh_hyst).state;
          const float low  = target - h / 2.0f;
          const float high = target + h / 2.0f;

          if (!id(relay_mist).state && rh <= low) id(relay_mist).turn_on();
          if (id(relay_mist).state && rh >= high) id(relay_mist).turn_off();

  # Fan post-run + turbo shadow + mister watchdog + dry detection + mode/cool lockout
  - interval: 1s
    then:
      - lambda: |-
          // --- Mode & cooling lockout handling ---
          const bool high_mode = (id(mode_select).state == "High-Temp");
          static bool last_high_mode = false;
          if (!last_high_mode && high_mode) {
            ESP_LOGI("mode", "Mode -> High-Temp");
          } else if (last_high_mode && !high_mode) {
            ESP_LOGI("mode", "Mode -> Normal, starting cooling lockout");
            id(cool_lockout_secs) = 3600;  // 60 minutes
          }
          last_high_mode = high_mode;

          if (id(cool_lockout_secs) > 0) {
            id(cool_lockout_secs)--;
          }

          // --- Turbo shadow: in High-Temp, turbo follows the heating mat ---
          const bool heater_on = id(relay_heat).state;
          if (high_mode && heater_on) {
            if (!id(relay_turbo).state) {
              ESP_LOGD("turbo", "High-Temp + heater ON -> TURBO ON");
            }
            id(relay_turbo).turn_on();
          } else {
            if (id(relay_turbo).state) {
              ESP_LOGD("turbo", "Turbo OFF (no High-Temp or heater OFF)");
            }
            id(relay_turbo).turn_off();
          }

          // --- Enforce cooling lockout & temp limit on the compressor ---
          if (id(relay_cool).state) {
            const float t = id(t_ctrl).state;
            if (high_mode || !isfinite(t) || t > 35.0f || id(cool_lockout_secs) > 0) {
              ESP_LOGW("cool", "Forcing COOL OFF due to mode/lockout/temp");
              id(relay_cool).turn_off();
            }
          }

          // --- Fan + mister + dry detection (your original logic, extended for turbo/cool) ---
          const bool mist_on = id(relay_mist).state;
          const bool last_mist = id(last_mist_on);
          if (last_mist && !mist_on) {
            id(fan_post_left_secs) = (uint32_t)(id(fan_postrun_minutes).state * 60.0f);
          }
          id(last_mist_on) = mist_on;

          if (!id(fan_auto).state) {
            if (id(relay_fan).state) ESP_LOGD("fan_auto", "FAN: Fan Auto OFF -> turning fan OFF");
            id(relay_fan).turn_off();
            id(fan_post_left_secs) = 0;
          } else {
            const bool turbo_on  = id(relay_turbo).state;
            const bool cooler_on = id(relay_cool).state;
            if (heater_on || turbo_on || cooler_on || mist_on) {
              if (!id(relay_fan).state) ESP_LOGD("fan_auto", "FAN: heat/turbo/cool/mister ON -> fan ON");
              id(relay_fan).turn_on();
              id(fan_post_left_secs) = 0;
            } else {
              if (id(fan_post_left_secs) > 0) {
                if (!id(relay_fan).state) ESP_LOGD("fan_auto", "FAN: post-run ticking -> fan ON");
                id(relay_fan).turn_on();
                id(fan_post_left_secs)--;
              } else {
                if (id(relay_fan).state) ESP_LOGD("fan_auto", "FAN: post-run done -> fan OFF");
                id(relay_fan).turn_off();
              }
            }
          }

          // Mister safety guard
          if (id(mist_lockout_secs) > 0) id(mist_lockout_secs)--;
          if (mist_on) {
            id(mist_on_secs)++;
            const uint32_t limit = (uint32_t)(id(rh_max_on_minutes).state * 60.0f);
            if (id(mist_on_secs) >= limit) {
              id(relay_mist).turn_off();
              id(mist_on_secs) = 0;
              id(mist_lockout_secs) = 60;
            }
          } else {
            id(mist_on_secs) = 0;
          }

          // Humidifier dry detection (unchanged)
          static bool was_on = false;
          if (mist_on && !was_on) {
            id(dry_rh_baseline) = id(rh_air).state;
            id(dry_check_elapsed) = 0;
          }
          was_on = mist_on;

          if (mist_on) {
            id(dry_check_elapsed)++;
            const uint32_t window = (uint32_t)(id(dry_check_minutes).state * 60.0f);
            if (id(dry_check_elapsed) == window) {
              const float rise_needed = id(dry_expected_rise).state;
              const float now_rh = id(rh_air).state;
              const bool ok = now_rh >= (id(dry_rh_baseline) + rise_needed - 1e-3f);
              if (!ok) {
                id(dry_fail_count) = id(dry_fail_count) + 1;
              } else {
                id(dry_fail_count) = 0;
                if (id(humidifier_dry_flag)) id(humidifier_dry_flag) = false;
              }
              const int needed = (int) id(dry_failures_needed).state;
              if (id(dry_fail_count) >= needed) id(humidifier_dry_flag) = true;
            }
          } else {
            id(dry_check_elapsed) = 0;
          }

  # Debug ticker
  - interval: 10s
    then:
      - lambda: |-
          const float t = id(t_ctrl).state;
          ESP_LOGD("thermo", "ControlTemp=%.2f°C (src=%s), Mode=%s, Heater=%s, Turbo=%s, Cooler=%s, Mister=%s, Fan=%s",
                   t,
                   id(temp_source_select).state.c_str(),
                   id(mode_select).state.c_str(),
                   id(relay_heat).state ? "ON" : "OFF",
                   id(relay_turbo).state ? "ON" : "OFF",
                   id(relay_cool).state ? "ON" : "OFF",
                   id(relay_mist).state ? "ON" : "OFF",
                   id(relay_fan).state ? "ON" : "OFF");